To build:

1. Download and install leiningen http://github.com/technomancy/leiningen
2. $ lein deps
3. $ lein install
4. $ java -cp `ls lib/*|xargs echo|sed 's/ /:/g'`:classes jline.ConsoleRunner clojure.main

core libs for compute cloud, blobstore, and ssh.

supported compute clouds: ec2, rackspace, rimuhosting, vcloud, terremark, hosting.com
supported blobstores: s3, rackspace, azure, atmos online

build upon the core is remote repl and cluster capabilities.

in a couple cases, we use an erlang convention of the ! syntax representing "reomote" (on another process) execution.
the first argument to ! in erlang is the pid, wheras in our api, it is an open ssh session or socket.
there is no ! operator or fn, we just use the ! suffix convention to communicate remote execution.

remote shell execution.
(sh! session "tar -xzf repl.tar.gz")

remote repl evaluation.
eval! 
(eval! socket (execute (workflow some-cascading-workflow)))

Cloud Examples:

Here's a quick example of how to view compute and blob resources.

(ns crane.jclouds
  (:use crane.blobstore)
  (:use crane.compute)
  (:use clojure.contrib.pprint)
)

 (def user  "rackspace_username")
 (def password "rackspace_password")

 (def compute-name "cloudservers")
 (def compute (compute-context compute-name user password))
 (def blobstore-name "cloudfiles")
 (def blobstore (blobstore-context blobstore-name user password ))

 (pprint (locations compute))
 (pprint (images compute))
 (pprint (nodes compute))
 (pprint (sizes compute))
 (run-node compute "testcluster")
 (destroy-nodes compute "testcluster")

 (pprint (containers blobstore))
 (pprint (blobs blobstore "your_container_name" )) 


TODO:
the persistent shell session using jsch ChannelShell is shaky at best, although exec works fine.
eval! may be simpler if we could use LineNumberingPushbackReader see comment in remote_repl.clj
stuff to poll and pull info from hadoop tracker url into repl
